package service

import (
	"fmt"
	"sort"
	"time"

	"github.com/JuanGQCadavid/now-project/services/pkgs/common/logs"
	"github.com/JuanGQCadavid/now-project/services/scheduledPatternsChecker/internal/core/domain"
	"github.com/JuanGQCadavid/now-project/services/scheduledPatternsChecker/internal/core/ports"
	"github.com/google/uuid"
)

type GenerateDatesResponse struct {
	Error  error
	Result []domain.Spot
}

type CheckerService struct {
	repository            ports.Repository
	confirmation          ports.Confirmation
	notification          ports.Notify
	coresNumber           int
	confirmationBatchSize int8
}

func NewCheckerService(repository ports.Repository, confirmation ports.Confirmation, notification ports.Notify, coresNumber int) *CheckerService {

	return &CheckerService{
		repository:            repository,
		confirmation:          confirmation,
		notification:          notification,
		coresNumber:           coresNumber,
		confirmationBatchSize: 25,
	}
}

// Steps:
//  1. Call Repository to find the sc ids and then delete them with all relationshipts
//  2. Send the deleted Ids to a Spot Activity SNS
func (srv *CheckerService) DeleteScheduleDatesFromSchedulePattern(schedulePatternIds []string) error {
	logs.Info.Printf("DeleteScheduleDatesFromSchedulePattern: schedulePatternIds: %+v \n", schedulePatternIds)

	datesIds, err := srv.repository.DeleteScheduleDatesFromSchedulePattern(schedulePatternIds)
	if err != nil {
		return err
	}

	for _, dateId := range datesIds {
		srv.notification.SchedulePatternActivity(ports.DateIdDeleted, domain.Notification{
			DateId: dateId,
		})
	}
	return nil
}

func (srv *CheckerService) OnSchedulePatternAppended(spots []domain.Spot, timeWindow int64) ([]domain.Spot, map[error][]domain.Spot) {

	spotsWithDates, err := srv.generateDates(spots, timeWindow)

	errors := make(map[error][]domain.Spot)

	if err != nil {
		logs.Error.Println("We got an error while processing the dates")
		errors[ports.ErrProcessingDates] = spots

		return nil, errors
	}

	for spotIndex, spot := range spots {
		logs.Info.Printf("Updating %d/%d, spot id: %s \n", spotIndex, len(spots), spot.SpotId)

		err = srv.repository.ConditionalDatesCreation(spot)

		if err != nil {
			logs.Error.Printf("We fail generating the dates for the spot %s, error: %s \n", spot.SpotId, err.Error())
			if errors[err] != nil {
				errors[err] = append(errors[err], spot)
			}
		}

	}

	if errors != nil && len(errors) > 0 {
		logs.Error.Println("We face a error while creating the spots on batch")

		totalErros := 0
		for spotError, spotsFailed := range errors {
			for _, spotFailed := range spotsFailed {
				totalErros++
				logs.Error.Printf("%s fail with %s error", spotFailed.SpotId, spotError)
			}
		}

		logs.Error.Printf("Total erros %d \n", totalErros)

		// We should send them to a DLQ or to avoid confirm them
		return nil, errors
	}

	// // 	4. Send spot id x dates Id x hostId to confirmation SQS
	// sendMessageErrors := srv.confirmation.SendConfirmationRequestOnBatch(spotsWithDates, srv.confirmationBatchSize)

	// // TODO What should we do in this case ?
	// if sendMessageErrors != nil {
	// 	logs.Error.Println("Confirmation service fail")
	// 	errors[ports.ErrSendingConfirmation] = spots

	// 	return nil, errors
	// }

	return spotsWithDates, nil
}

// Procedure:

// 	1. Bring all schedule patterns that are in the repository that:
// 		- Pattern is active
// 		- Spot Id is not eliminated
// 		- Current date is btw Start and end date

// 	2. Map the request btw the active vCPU

// 	3.  Generate Dates with status status pending_to_confirmation (By doing bulk operation)
// 		Check witch dates are already generated by having checked_until property
// 		as the threshold

// 	4. Send spot id x dates Id x hostId to confirmation SQS

func (srv *CheckerService) GenerateDatesFromRepository(timeWindow int64) ([]domain.Spot, error) {

	activeSchedulePatterns, err := srv.repository.FetchActiveSchedulePatterns()

	if err != nil {
		logs.Error.Println("Process fail to fecth active spots")
		return nil, ports.ErrOnRepository
	}

	// 	2. Map the request btw the active vCPU
	var spotsWithDates []domain.Spot

	if srv.coresNumber == 1 {
		logs.Info.Println("Going with only one core, avoiding parallel process.")
		spotsWithDates, err = srv.generateDates(activeSchedulePatterns, timeWindow)

		if err != nil {
			logs.Error.Println("We got an error while processing the dates")
			return nil, ports.ErrProcessingDates
		}

	} else if srv.coresNumber > 1 {
		logs.Info.Println("Parallel proces for ", srv.coresNumber, " cores")
		datesPerCore := srv.splitDatesPerCore(srv.getSortedSpotsPatternsByDeep(activeSchedulePatterns), srv.coresNumber)

		logs.Info.Println("Creating process")
		ch := make(chan GenerateDatesResponse)
		for _, spot := range datesPerCore {
			go srv.generateDatesParallel(spot, timeWindow, ch)
		}
		logs.Info.Println("Done")

		logs.Info.Println("Starting waiting proccess")
		for i, _ := range datesPerCore {
			response := <-ch

			logs.Info.Println("Response ", i, " of ", srv.coresNumber)
			if response.Error != nil {
				logs.Error.Println("We got an error while processing the dates. Error: ", response.Error.Error())
				return nil, ports.ErrProcessingDates
			}

			spotsWithDates = append(spotsWithDates, response.Result...)

		}
		logs.Info.Println("Done")

	} else {
		logs.Error.Println("There is a problem with the cors number ", srv.coresNumber)
		return nil, ports.ErrInvalidCors
	}

	errors := srv.repository.UpdateSpotsByBatch(spotsWithDates, int(srv.confirmationBatchSize))

	if errors != nil {
		logs.Error.Println("We face a error while creating the spots on batch")

		// TODO -> lets iterare over all erros, if the number of erros is less than the total spots then we could keep with a
		// partial error

		for spotId, spotError := range errors {
			logs.Error.Printf("%s fail with %s error", spotId.SpotId, spotError)
		}

		return nil, ports.ErrServiceParcialOutage
	}

	// 	4. Send spot id x dates Id x hostId to confirmation SQS
	sendMessageErrors := srv.confirmation.SendConfirmationRequestOnBatch(spotsWithDates, srv.confirmationBatchSize)

	// TODO What should we do in this case ?
	if sendMessageErrors != nil {
		logs.Error.Println("Confirmation service fail")
		return nil, ports.ErrSendingConfirmation
	}

	return spotsWithDates, nil
}

func (srv *CheckerService) getSortedSpotsPatternsByDeep(spots []domain.Spot) []domain.SpotPatternsDeep {

	result := make([]domain.SpotPatternsDeep, len(spots))

	for i, spot := range spots {
		result[i] = domain.SpotPatternsDeep{
			Spot: spot,
			Deep: len(spot.SchedulePatterns),
		}
	}

	if len(result) < 2 {
		logs.Warning.Println("Avoiding sort as len is ", len(result))
		return result
	}

	sort.Slice(result, func(i, j int) bool {
		return result[i].Deep <= result[j].Deep
	})

	return result
}

func (srv *CheckerService) splitDatesPerCore(spots []domain.SpotPatternsDeep, coreNumber int) [][]domain.Spot {
	result := make([][]domain.Spot, coreNumber)
	counter := make([]int, coreNumber)

	// counterI := 0

	for left := len(spots) - 1; left >= 0; left-- {
		spot := spots[left]
		minIndex := 0
		for counterI := 0; counterI < coreNumber; counterI++ {
			if counter[counterI] < counter[minIndex] {
				minIndex = counterI
			}
		}

		result[minIndex] = append(result[minIndex], spot.Spot)
		counter[minIndex] += spot.Deep
	}
	return result
}

func (srv *CheckerService) generateDatesParallel(spots []domain.Spot, timeWindow int64, ch chan GenerateDatesResponse) {

	result, err := srv.generateDates(spots, timeWindow)

	response := GenerateDatesResponse{
		Error:  err,
		Result: result,
	}

	ch <- response
}

func (srv *CheckerService) generateDates(spots []domain.Spot, timeWindow int64) ([]domain.Spot, error) {

	startProcessTime := time.Now()
	limitTime := time.Unix(startProcessTime.Unix()+timeWindow, 0)
	dayJump := 24 * time.Hour

	logs.Info.Printf("startProcessTime: %s, limitTime: %s, daysBtw: %s, dayJump: %s", startProcessTime.Format(time.DateTime), limitTime.Format(time.DateTime), limitTime.Sub(startProcessTime), dayJump)

	for i, spot := range spots {

		fmt.Printf("Checking spot id %+v with a schedulePatterns len of %d \n", spot.SpotId, len(spot.SchedulePatterns))

		for ii, schedulePattern := range spot.SchedulePatterns {
			dates := make(map[string]domain.Dates, 0)
			var checkingTime time.Time = startProcessTime // Maybe this could bring troubles

			startDate, _ := time.Parse(time.DateOnly, schedulePattern.FromDate)
			endDate, _ := time.Parse(time.DateOnly, schedulePattern.ToDate)

			startTime, _ := time.Parse(time.TimeOnly, schedulePattern.StartTime)
			endHour, _ := time.Parse(time.TimeOnly, schedulePattern.EndTime)
			durationBtw := endHour.Sub(startTime)

			if schedulePattern.CheckedUpTo != 0 && schedulePattern.CheckedUpTo >= startProcessTime.Unix() {
				checkingTime = time.Unix(schedulePattern.CheckedUpTo, 0)

			}

			for checkingTime.Compare(limitTime) <= 0 && checkingTime.Compare(startDate) >= 0 && checkingTime.Compare(endDate) <= 0 {
				weekDay := checkingTime.Weekday()

				if domain.IsMonday(schedulePattern.Day) && weekDay == time.Monday ||
					domain.IsTuesday(schedulePattern.Day) && weekDay == time.Tuesday ||
					domain.IsWednesday(schedulePattern.Day) && weekDay == time.Wednesday ||
					domain.IsThursday(schedulePattern.Day) && weekDay == time.Thursday ||
					domain.IsFriday(schedulePattern.Day) && weekDay == time.Friday ||
					domain.IsSaturday(schedulePattern.Day) && weekDay == time.Saturday ||
					domain.IsSunday(schedulePattern.Day) && weekDay == time.Sunday {

					newDate := domain.Dates{
						DateId:                        uuid.NewString(),
						DurationApproximatedInSeconds: int64(durationBtw.Seconds() / 60),
						StartTime:                     schedulePattern.StartTime,
						Date:                          checkingTime.Format(time.DateOnly),
						HostId:                        schedulePattern.HostId,
					}
					schedulePattern.CheckedUpTo = checkingTime.Unix()
					logs.Info.Printf("Date %s create for sp %s on %s \n", newDate.DateId, schedulePattern.Id, newDate.Date)
					dates[newDate.DateId] = newDate
				}
				checkingTime = checkingTime.Add(dayJump)
			}

			schedulePattern.Dates = make([]domain.Dates, len(dates))
			index := 0
			for _, date := range dates {
				schedulePattern.Dates[index] = date
				index++
			}
			spot.SchedulePatterns[ii] = schedulePattern
			spots[i] = spot
		}
	}
	return spots, nil
}
