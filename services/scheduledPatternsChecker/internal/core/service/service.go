package service

import (
	"fmt"
	"sort"
	"time"

	"github.com/JuanGQCadavid/now-project/services/pkgs/common/logs"
	"github.com/JuanGQCadavid/now-project/services/scheduledPatternsChecker/internal/core/domain"
	"github.com/JuanGQCadavid/now-project/services/scheduledPatternsChecker/internal/core/ports"
	"github.com/google/uuid"
)

type GenerateDatesResponse struct {
	Error  error
	Result []domain.Spot
}

type CheckerService struct {
	repository            ports.Repository
	confirmation          ports.Confirmation
	coresNumber           int
	confirmationBatchSize int8
}

func NewCheckerService(repository ports.Repository, confirmation ports.Confirmation, coresNumber int) *CheckerService {

	return &CheckerService{
		repository:            repository,
		confirmation:          confirmation,
		coresNumber:           coresNumber,
		confirmationBatchSize: 25,
	}
}

// Procedure:

// 	1. Bring all schedule patterns that are in the repository that:
// 		- Pattern is active
// 		- Spot Id is not eliminated
// 		- Current date is btw Start and end date

// 	2. Map the request btw the active vCPU

// 	3.  Generate Dates with status status pending_to_confirmation (By doing bulk operation)
// 		Check witch dates are already generated by having checked_until property
// 		as the threshold

// 	4. Send spot id x dates Id x hostId to confirmation SQS

func (srv *CheckerService) GenerateDatesFromRepository(timeWindow int64) ([]domain.Spot, error) {

	activeSchedulePatterns, err := srv.repository.FetchActiveSchedulePatterns()

	if err != nil {
		logs.Error.Println("Process fail to fecth active spots")
		return nil, ports.ErrOnRepository
	}

	// 	2. Map the request btw the active vCPU
	var spotsWithDates []domain.Spot

	if srv.coresNumber == 1 {
		logs.Info.Println("Going with only one core, avoiding parallel process.")
		spotsWithDates, err = srv.generateDates(activeSchedulePatterns, timeWindow)

		if err != nil {
			logs.Error.Println("We got an error while processing the dates")
			return nil, ports.ErrProcessingDates
		}

	} else if srv.coresNumber > 1 {
		logs.Info.Println("Parallel proces for ", srv.coresNumber, " cores")
		datesPerCore := srv.splitDatesPerCore(srv.getSortedSpotsPatternsByDeep(activeSchedulePatterns), srv.coresNumber)

		logs.Info.Println("Creating process")
		ch := make(chan GenerateDatesResponse)
		for _, spot := range datesPerCore {
			go srv.generateDatesParallel(spot, timeWindow, ch)
		}
		logs.Info.Println("Done")

		logs.Info.Println("Starting waiting proccess")
		for i, _ := range datesPerCore {
			response := <-ch

			logs.Info.Println("Response ", i, " of ", srv.coresNumber)
			if response.Error != nil {
				logs.Error.Println("We got an error while processing the dates. Error: ", response.Error.Error())
				return nil, ports.ErrProcessingDates
			}

			spotsWithDates = append(spotsWithDates, response.Result...)

		}
		logs.Info.Println("Done")

	} else {
		logs.Error.Println("There is a problem with the cors number ", srv.coresNumber)
		return nil, ports.ErrInvalidCors
	}

	// TODO -> We are missing updating schedule patterns checkeduntil
	// TODO -> We are missing dates creation!! jajajaja

	// 	4. Send spot id x dates Id x hostId to confirmation SQS
	sendMessageErrors := srv.confirmation.SendConfirmationRequestOnBatch(spotsWithDates, srv.confirmationBatchSize)

	// TODO What should we do in this case ?
	if sendMessageErrors != nil {
		logs.Error.Println("Confirmation service fail")
		return nil, ports.ErrSendingConfirmation
	}

	return spotsWithDates, nil
}

func (srv *CheckerService) getSortedSpotsPatternsByDeep(spots []domain.Spot) []domain.SpotPatternsDeep {

	result := make([]domain.SpotPatternsDeep, len(spots))

	for i, spot := range spots {
		result[i] = domain.SpotPatternsDeep{
			Spot: spot,
			Deep: len(spot.SchedulePatterns),
		}
	}

	if len(result) < 2 {
		logs.Warning.Println("Avoiding sort as len is ", len(result))
		return result
	}

	sort.Slice(result, func(i, j int) bool {
		return result[i].Deep <= result[j].Deep
	})

	return result
}

func (srv *CheckerService) splitDatesPerCore(spots []domain.SpotPatternsDeep, coreNumber int) [][]domain.Spot {
	result := make([][]domain.Spot, coreNumber)
	counter := make([]int, coreNumber)

	// counterI := 0

	for left := len(spots) - 1; left >= 0; left-- {
		spot := spots[left]
		minIndex := 0
		for counterI := 0; counterI < coreNumber; counterI++ {
			if counter[counterI] < counter[minIndex] {
				minIndex = counterI
			}
		}

		result[minIndex] = append(result[minIndex], spot.Spot)
		counter[minIndex] += spot.Deep
	}
	return result
}

func (srv *CheckerService) generateDatesParallel(spots []domain.Spot, timeWindow int64, ch chan GenerateDatesResponse) {

	result, err := srv.generateDates(spots, timeWindow)

	response := GenerateDatesResponse{
		Error:  err,
		Result: result,
	}

	ch <- response
}

func (srv *CheckerService) generateDates(spots []domain.Spot, timeWindow int64) ([]domain.Spot, error) {

	startProcessTime := time.Now()
	limitTime := time.Unix(startProcessTime.Unix()+timeWindow, 0)
	dayJump := 24 * time.Hour

	logs.Info.Printf("startProcessTime: %s, limitTime: %s, daysBtw: %s, dayJump: %s", startProcessTime.Format(time.DateTime), limitTime.Format(time.DateTime), limitTime.Sub(startProcessTime), dayJump)

	for i, spot := range spots {
		dates := make(map[string]domain.Dates, 0)

		fmt.Printf("Checking spot id %+v with a schedulePatterns len of %d \n", spot.SpotId, len(spot.SchedulePatterns))

		for ii, schedulePattern := range spot.SchedulePatterns {
			var checkingTime time.Time = startProcessTime // Maybe this could bring troubles

			startDate, _ := time.Parse(time.DateOnly, schedulePattern.FromDate)
			endDate, _ := time.Parse(time.DateOnly, schedulePattern.ToDate)

			startTime, _ := time.Parse(time.TimeOnly, schedulePattern.StartTime)
			endHour, _ := time.Parse(time.TimeOnly, schedulePattern.EndTime)
			durationBtw := endHour.Sub(startTime)

			if schedulePattern.CheckedUpTo != 0 {
				checkingTime = time.Unix(schedulePattern.CheckedUpTo, 0)
			}

			for checkingTime.Compare(limitTime) <= 0 && checkingTime.Compare(startDate) >= 0 && checkingTime.Compare(endDate) <= 0 {
				weekDay := checkingTime.Weekday()

				if domain.IsMonday(schedulePattern.Day) && weekDay == time.Monday ||
					domain.IsTuesday(schedulePattern.Day) && weekDay == time.Tuesday ||
					domain.IsWednesday(schedulePattern.Day) && weekDay == time.Wednesday ||
					domain.IsThursday(schedulePattern.Day) && weekDay == time.Thursday ||
					domain.IsFriday(schedulePattern.Day) && weekDay == time.Friday ||
					domain.IsSaturday(schedulePattern.Day) && weekDay == time.Saturday ||
					domain.IsSunday(schedulePattern.Day) && weekDay == time.Sunday {

					newDate := domain.Dates{
						DateId:                        uuid.NewString(),
						DurationApproximatedInSeconds: int64(durationBtw.Seconds()),
						StartTime:                     schedulePattern.StartTime,
						Date:                          checkingTime.Format(time.DateOnly),
						HostId:                        schedulePattern.HostId,
					}
					schedulePattern.CheckedUpTo = checkingTime.Unix()

					spot.SchedulePatterns[ii] = schedulePattern

					logs.Info.Printf("Date %s create for sp %s on %s \n", newDate.DateId, schedulePattern.Id, newDate.Date)
					dates[newDate.DateId] = newDate
				}
				checkingTime = checkingTime.Add(dayJump)
			}

			spot.Dates = make([]domain.Dates, len(dates))
			index := 0

			for _, date := range dates {
				spot.Dates[index] = date
				index++
			}

			spots[i] = spot

		}
	}
	return spots, nil
}
