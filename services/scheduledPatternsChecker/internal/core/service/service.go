package service

import (
	"runtime"
	"sort"

	"github.com/JuanGQCadavid/now-project/services/pkgs/common/logs"
	"github.com/JuanGQCadavid/now-project/services/scheduledPatternsChecker/internal/core/domain"
	"github.com/JuanGQCadavid/now-project/services/scheduledPatternsChecker/internal/core/ports"
)

type GenerateDatesResponse struct {
	Error  error
	Result []domain.Spot
}

type CheckerService struct {
	repository            ports.Repository
	confirmation          ports.Confirmation
	coresNumber           int
	confirmationBatchSize int8
}

func NewCheckerService(repository ports.Repository, confirmation ports.Confirmation) *CheckerService {

	cores := runtime.NumCPU()

	return &CheckerService{
		repository:            repository,
		confirmation:          confirmation,
		coresNumber:           cores,
		confirmationBatchSize: 25,
	}
}

// Procedure:

// 	1. Bring all schedule patterns that are in the repository that:
// 		- Pattern is active
// 		- Spot Id is not eliminated
// 		- Current date is btw Start and end date

// 	2. Map the request btw the active vCPU

// 	3.  Generate Dates with status status pending_to_confirmation (By doing bulk operation)
// 		Check witch dates are already generated by having checked_until property
// 		as the threshold

// 	4. Send spot id x dates Id x hostId to confirmation SQS

func (srv *CheckerService) GenerateDatesFromRepository(timeWindow int) error {

	activeSchedulePatterns, err := srv.repository.FetchActiveSchedulePatterns()

	if err != nil {
		logs.Error.Println("Process fail to fecth active spots")
		return ports.ErrOnRepository
	}

	// 	2. Map the request btw the active vCPU
	var spotsWithDates []domain.Spot

	if srv.coresNumber == 1 {
		logs.Info.Println("Going with only one core, avoiding parallel process.")
		spotsWithDates, err = srv.GenerateDates(activeSchedulePatterns, timeWindow)

		if err != nil {
			logs.Error.Println("We got an error while processing the dates")
			return ports.ErrProcessingDates
		}

	} else if srv.coresNumber > 1 {
		logs.Info.Println("Parallel proces for ", srv.coresNumber, " cores")
		datesPerCore := srv.SplitDatesPerCore(srv.GetSortedSpotsPatternsByDeep(activeSchedulePatterns), srv.coresNumber)

		logs.Info.Println("Creating process")
		ch := make(chan GenerateDatesResponse)
		for _, spot := range datesPerCore {
			go srv.GenerateDatesParallel(spot, timeWindow, ch)
		}
		logs.Info.Println("Done")

		logs.Info.Println("Starting waiting proccess")
		for i, _ := range datesPerCore {
			response := <-ch

			logs.Info.Println("Response ", i, " of ", srv.coresNumber)
			if response.Error != nil {
				logs.Error.Println("We got an error while processing the dates. Error: ", response.Error.Error())
				return ports.ErrProcessingDates
			}

			spotsWithDates = append(spotsWithDates, response.Result...)

		}
		logs.Info.Println("Done")

	} else {
		logs.Error.Println("There is a problem with the cors number ", srv.coresNumber)
		return ports.ErrInvalidCors
	}

	// 	4. Send spot id x dates Id x hostId to confirmation SQS
	err = srv.confirmation.SendConfirmationRequestOnBatch(spotsWithDates, srv.confirmationBatchSize)

	if err != nil {
		logs.Error.Println("Confirmation service fail")
		return ports.ErrSendingConfirmation
	}

	return nil
}

// TODO: Put private
// Working!
func (srv *CheckerService) GetSortedSpotsPatternsByDeep(spots []domain.Spot) []domain.SpotPatternsDeep {

	result := make([]domain.SpotPatternsDeep, len(spots))

	for i, spot := range spots {
		result[i] = domain.SpotPatternsDeep{
			Spot: spot,
			Deep: len(spot.SchedulePatterns),
		}
	}

	if len(result) < 2 {
		logs.Warning.Println("Avoiding sort as len is ", len(result))
		return result
	}

	sort.Slice(result, func(i, j int) bool {
		return result[i].Deep <= result[j].Deep
	})

	return result
}

// TODO: Put private
// Working!
func (srv *CheckerService) SplitDatesPerCore(spots []domain.SpotPatternsDeep, coreNumber int) [][]domain.Spot {
	result := make([][]domain.Spot, coreNumber)
	counter := make([]int, coreNumber)

	// counterI := 0

	for left := len(spots) - 1; left >= 0; left-- {
		spot := spots[left]
		minIndex := 0
		for counterI := 0; counterI < coreNumber; counterI++ {
			if counter[counterI] < counter[minIndex] {
				minIndex = counterI
			}
		}

		result[minIndex] = append(result[minIndex], spot.Spot)
		counter[minIndex] += spot.Deep
	}
	return result
}

func (srv *CheckerService) GenerateDatesParallel(spots []domain.Spot, timeWindow int, ch chan GenerateDatesResponse) {

	result, err := srv.GenerateDates(spots, timeWindow)

	response := GenerateDatesResponse{
		Error:  err,
		Result: result,
	}

	ch <- response
}

// TODO: Put private
func (srv *CheckerService) GenerateDates(spots []domain.Spot, timeWindow int) ([]domain.Spot, error) {
	return nil, nil
}
