package service

import (
	"fmt"
	"runtime"
	"sort"
	"time"

	"github.com/JuanGQCadavid/now-project/services/pkgs/common/logs"
	"github.com/JuanGQCadavid/now-project/services/scheduledPatternsChecker/internal/core/domain"
	"github.com/JuanGQCadavid/now-project/services/scheduledPatternsChecker/internal/core/ports"
	"github.com/google/uuid"
)

type GenerateDatesResponse struct {
	Error  error
	Result []domain.Spot
}

type CheckerService struct {
	repository            ports.Repository
	confirmation          ports.Confirmation
	coresNumber           int
	confirmationBatchSize int8
}

func NewCheckerService(repository ports.Repository, confirmation ports.Confirmation) *CheckerService {

	cores := runtime.NumCPU()

	return &CheckerService{
		repository:            repository,
		confirmation:          confirmation,
		coresNumber:           cores,
		confirmationBatchSize: 25,
	}
}

// Procedure:

// 	1. Bring all schedule patterns that are in the repository that:
// 		- Pattern is active
// 		- Spot Id is not eliminated
// 		- Current date is btw Start and end date

// 	2. Map the request btw the active vCPU

// 	3.  Generate Dates with status status pending_to_confirmation (By doing bulk operation)
// 		Check witch dates are already generated by having checked_until property
// 		as the threshold

// 	4. Send spot id x dates Id x hostId to confirmation SQS

func (srv *CheckerService) GenerateDatesFromRepository(timeWindow int64) ([]domain.Spot, error) {

	activeSchedulePatterns, err := srv.repository.FetchActiveSchedulePatterns()

	if err != nil {
		logs.Error.Println("Process fail to fecth active spots")
		return nil, ports.ErrOnRepository
	}

	// 	2. Map the request btw the active vCPU
	var spotsWithDates []domain.Spot

	if srv.coresNumber == 1 {
		logs.Info.Println("Going with only one core, avoiding parallel process.")
		spotsWithDates, err = srv.GenerateDates(activeSchedulePatterns, timeWindow)

		if err != nil {
			logs.Error.Println("We got an error while processing the dates")
			return nil, ports.ErrProcessingDates
		}

	} else if srv.coresNumber > 1 {
		logs.Info.Println("Parallel proces for ", srv.coresNumber, " cores")
		datesPerCore := srv.SplitDatesPerCore(srv.GetSortedSpotsPatternsByDeep(activeSchedulePatterns), srv.coresNumber)

		logs.Info.Println("Creating process")
		ch := make(chan GenerateDatesResponse)
		for _, spot := range datesPerCore {
			go srv.GenerateDatesParallel(spot, timeWindow, ch)
		}
		logs.Info.Println("Done")

		logs.Info.Println("Starting waiting proccess")
		for i, _ := range datesPerCore {
			response := <-ch

			logs.Info.Println("Response ", i, " of ", srv.coresNumber)
			if response.Error != nil {
				logs.Error.Println("We got an error while processing the dates. Error: ", response.Error.Error())
				return nil, ports.ErrProcessingDates
			}

			spotsWithDates = append(spotsWithDates, response.Result...)

		}
		logs.Info.Println("Done")

	} else {
		logs.Error.Println("There is a problem with the cors number ", srv.coresNumber)
		return nil, ports.ErrInvalidCors
	}

	// 	4. Send spot id x dates Id x hostId to confirmation SQS
	err = srv.confirmation.SendConfirmationRequestOnBatch(spotsWithDates, srv.confirmationBatchSize)

	if err != nil {
		logs.Error.Println("Confirmation service fail")
		return nil, ports.ErrSendingConfirmation
	}

	return spotsWithDates, nil
}

// TODO: Put private
// Working!
func (srv *CheckerService) GetSortedSpotsPatternsByDeep(spots []domain.Spot) []domain.SpotPatternsDeep {

	result := make([]domain.SpotPatternsDeep, len(spots))

	for i, spot := range spots {
		result[i] = domain.SpotPatternsDeep{
			Spot: spot,
			Deep: len(spot.SchedulePatterns),
		}
	}

	if len(result) < 2 {
		logs.Warning.Println("Avoiding sort as len is ", len(result))
		return result
	}

	sort.Slice(result, func(i, j int) bool {
		return result[i].Deep <= result[j].Deep
	})

	return result
}

// TODO: Put private
// Working!
func (srv *CheckerService) SplitDatesPerCore(spots []domain.SpotPatternsDeep, coreNumber int) [][]domain.Spot {
	result := make([][]domain.Spot, coreNumber)
	counter := make([]int, coreNumber)

	// counterI := 0

	for left := len(spots) - 1; left >= 0; left-- {
		spot := spots[left]
		minIndex := 0
		for counterI := 0; counterI < coreNumber; counterI++ {
			if counter[counterI] < counter[minIndex] {
				minIndex = counterI
			}
		}

		result[minIndex] = append(result[minIndex], spot.Spot)
		counter[minIndex] += spot.Deep
	}
	return result
}

func (srv *CheckerService) GenerateDatesParallel(spots []domain.Spot, timeWindow int64, ch chan GenerateDatesResponse) {

	result, err := srv.GenerateDates(spots, timeWindow)

	response := GenerateDatesResponse{
		Error:  err,
		Result: result,
	}

	ch <- response
}

// TODO: Put private
func (srv *CheckerService) GenerateDates(spots []domain.Spot, timeWindow int64) ([]domain.Spot, error) {

	limitTime := time.Unix(time.Now().Unix()+timeWindow, 0)
	dayJump := 24 * time.Hour
	dates := make([]domain.Dates, 0)

	for i, spot := range spots {
		fmt.Printf("\n")

		fmt.Printf("spot: %+v, sp len %d \n", spot, len(spot.SchedulePatterns))
		fmt.Printf("limitTime: %s \nlimitTime: %s \n", limitTime.String(), dayJump.String())

		for _, schedulePattern := range spot.SchedulePatterns {
			var startCheckingTime time.Time

			startTime, _ := time.Parse(time.DateOnly, schedulePattern.FromDate)
			endTime, _ := time.Parse(time.DateOnly, schedulePattern.ToDate)

			startHour, _ := time.Parse(time.TimeOnly, schedulePattern.StartTime)
			endHour, _ := time.Parse(time.TimeOnly, schedulePattern.EndTime)
			durationBtw := endHour.Sub(startHour)

			if schedulePattern.CheckedUpTo != 0 {
				startCheckingTime = time.Unix(schedulePattern.CheckedUpTo, 0)
			} else {
				startCheckingTime = time.Now()
			}

			for startCheckingTime.Compare(limitTime) <= 0 && startCheckingTime.Compare(startTime) >= 0 && startCheckingTime.Compare(endTime) <= 0 {
				weekDay := startCheckingTime.Weekday()

				if domain.IsMonday(schedulePattern.Day) && weekDay == time.Monday ||
					domain.IsTuesday(schedulePattern.Day) && weekDay == time.Tuesday ||
					domain.IsWednesday(schedulePattern.Day) && weekDay == time.Wednesday ||
					domain.IsThursday(schedulePattern.Day) && weekDay == time.Thursday ||
					domain.IsFriday(schedulePattern.Day) && weekDay == time.Friday ||
					domain.IsSaturday(schedulePattern.Day) && weekDay == time.Saturday ||
					domain.IsSunday(schedulePattern.Day) && weekDay == time.Sunday {

					newDate := domain.Dates{
						DateId:                        uuid.NewString(),
						DurationApproximatedInSeconds: int64(durationBtw.Seconds()),
						StartTime:                     schedulePattern.StartTime,
						Date:                          startCheckingTime.Format(time.DateOnly),
						HostId:                        schedulePattern.HostId,
					}
					dates = append(dates, newDate)
				}
				startCheckingTime = startCheckingTime.Add(dayJump)
			}

			spot.Dates = dates
			spots[i] = spot

		}
	}
	return spots, nil
}
