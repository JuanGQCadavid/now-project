package service

import (
	"runtime"

	"github.com/JuanGQCadavid/now-project/services/pkgs/common/logs"
	"github.com/JuanGQCadavid/now-project/services/scheduledPatternsChecker/internal/core/domain"
	"github.com/JuanGQCadavid/now-project/services/scheduledPatternsChecker/internal/core/ports"
)

type GenerateDatesResponse struct {
	Error  error
	Result []domain.Spot
}

type CheckerService struct {
	repository            ports.Repository
	confirmation          ports.Confirmation
	coresNumber           int
	confirmationBatchSize int8
}

func NewCheckerService(repository ports.Repository, confirmation ports.Confirmation) *CheckerService {

	cores := runtime.NumCPU()

	return &CheckerService{
		repository:            repository,
		confirmation:          confirmation,
		coresNumber:           cores,
		confirmationBatchSize: 25,
	}
}

// Procedure:

// 	1. Bring all schedule patterns that are in the repository that:
// 		- Pattern is active
// 		- Spot Id is not eliminated
// 		- Current date is btw Start and end date

// 	2. Map the request btw the active vCPU

// 	3.  Generate Dates with status status pending_to_confirmation (By doing bulk operation)
// 		Check witch dates are already generated by having checked_until property
// 		as the threshold

// 	4. Send spot id x dates Id x hostId to confirmation SQS

func (srv *CheckerService) GenerateDatesFromRepository(timeWindow int) error {

	activeSchedulePatterns, err := srv.repository.FetchActiveSchedulePatterns()

	if err != nil {
		logs.Error.Println("Process fail to fecth active spots")
		return ports.ErrOnRepository
	}

	// 	2. Map the request btw the active vCPU
	var spotsWithDates []domain.Spot

	if srv.coresNumber == 1 {
		logs.Info.Println("Going with only one core, avoiding parallel process.")
		spotsWithDates, err = srv.generateDates(activeSchedulePatterns, timeWindow)

		if err != nil {
			logs.Error.Println("We got an error while processing the dates")
			return ports.ErrProcessingDates
		}

	} else if srv.coresNumber > 1 {
		logs.Info.Println("Parallel proces for ", srv.coresNumber, " cores")
		datesPerCore := srv.splitDatesPerCore(srv.getSortedSpotsPatternsByDeep(activeSchedulePatterns), srv.coresNumber)

		logs.Info.Println("Creating process")
		ch := make(chan GenerateDatesResponse)
		for _, spot := range datesPerCore {
			go srv.generateDatesParallel(spot, timeWindow, ch)
		}
		logs.Info.Println("Done")

		logs.Info.Println("Starting waiting proccess")
		for i, _ := range datesPerCore {
			response := <-ch

			logs.Info.Println("Response ", i, " of ", srv.coresNumber)
			if response.Error != nil {
				logs.Error.Println("We got an error while processing the dates")
				return ports.ErrProcessingDates
			}

			spotsWithDates = append(spotsWithDates, response.Result...)

		}
		logs.Info.Println("Done")

	} else {
		logs.Error.Println("There is a problem with the cors number ", srv.coresNumber)
		return ports.ErrInvalidCors
	}

	// 	4. Send spot id x dates Id x hostId to confirmation SQS
	err = srv.confirmation.SendConfirmationRequestOnBatch(spotsWithDates, srv.confirmationBatchSize)

	if err != nil {
		logs.Error.Println("Confirmation service fail")
		return ports.ErrSendingConfirmation
	}

	return nil
}

func (srv *CheckerService) getSortedSpotsPatternsByDeep(spots []domain.Spot) []domain.SpotPatternsDeep {

	return nil
}

func (srv *CheckerService) splitDatesPerCore(spots []domain.SpotPatternsDeep, coreNumber int) [][]domain.Spot {
	return nil
}

func (srv *CheckerService) generateDatesParallel(spots []domain.Spot, timeWindow int, ch chan GenerateDatesResponse) {

}

func (srv *CheckerService) generateDates(spots []domain.Spot, timeWindow int) ([]domain.Spot, error) {
	return nil, nil
}
