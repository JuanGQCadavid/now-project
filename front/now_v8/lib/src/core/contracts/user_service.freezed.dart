// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_service.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$UserError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserErrorCopyWith<$Res> {
  factory $UserErrorCopyWith(UserError value, $Res Function(UserError) then) =
      _$UserErrorCopyWithImpl<$Res, UserError>;
}

/// @nodoc
class _$UserErrorCopyWithImpl<$Res, $Val extends UserError>
    implements $UserErrorCopyWith<$Res> {
  _$UserErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserDoesNotExistCopyWith<$Res> {
  factory _$$UserDoesNotExistCopyWith(
          _$UserDoesNotExist value, $Res Function(_$UserDoesNotExist) then) =
      __$$UserDoesNotExistCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserDoesNotExistCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$UserDoesNotExist>
    implements _$$UserDoesNotExistCopyWith<$Res> {
  __$$UserDoesNotExistCopyWithImpl(
      _$UserDoesNotExist _value, $Res Function(_$UserDoesNotExist) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserDoesNotExist implements UserDoesNotExist {
  _$UserDoesNotExist();

  @override
  String toString() {
    return 'UserError.userDoesNotExist()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserDoesNotExist);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return userDoesNotExist();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return userDoesNotExist?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (userDoesNotExist != null) {
      return userDoesNotExist();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return userDoesNotExist(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return userDoesNotExist?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (userDoesNotExist != null) {
      return userDoesNotExist(this);
    }
    return orElse();
  }
}

abstract class UserDoesNotExist implements UserError {
  factory UserDoesNotExist() = _$UserDoesNotExist;
}

/// @nodoc
abstract class _$$phoneNumberAlreadyTakenCopyWith<$Res> {
  factory _$$phoneNumberAlreadyTakenCopyWith(_$phoneNumberAlreadyTaken value,
          $Res Function(_$phoneNumberAlreadyTaken) then) =
      __$$phoneNumberAlreadyTakenCopyWithImpl<$Res>;
}

/// @nodoc
class __$$phoneNumberAlreadyTakenCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$phoneNumberAlreadyTaken>
    implements _$$phoneNumberAlreadyTakenCopyWith<$Res> {
  __$$phoneNumberAlreadyTakenCopyWithImpl(_$phoneNumberAlreadyTaken _value,
      $Res Function(_$phoneNumberAlreadyTaken) _then)
      : super(_value, _then);
}

/// @nodoc

class _$phoneNumberAlreadyTaken implements phoneNumberAlreadyTaken {
  _$phoneNumberAlreadyTaken();

  @override
  String toString() {
    return 'UserError.phoneNumberAlreadyTaken()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$phoneNumberAlreadyTaken);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return phoneNumberAlreadyTaken();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return phoneNumberAlreadyTaken?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (phoneNumberAlreadyTaken != null) {
      return phoneNumberAlreadyTaken();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return phoneNumberAlreadyTaken(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return phoneNumberAlreadyTaken?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (phoneNumberAlreadyTaken != null) {
      return phoneNumberAlreadyTaken(this);
    }
    return orElse();
  }
}

abstract class phoneNumberAlreadyTaken implements UserError {
  factory phoneNumberAlreadyTaken() = _$phoneNumberAlreadyTaken;
}

/// @nodoc
abstract class _$$otpAliveCopyWith<$Res> {
  factory _$$otpAliveCopyWith(
          _$otpAlive value, $Res Function(_$otpAlive) then) =
      __$$otpAliveCopyWithImpl<$Res>;
}

/// @nodoc
class __$$otpAliveCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$otpAlive>
    implements _$$otpAliveCopyWith<$Res> {
  __$$otpAliveCopyWithImpl(_$otpAlive _value, $Res Function(_$otpAlive) _then)
      : super(_value, _then);
}

/// @nodoc

class _$otpAlive implements otpAlive {
  _$otpAlive();

  @override
  String toString() {
    return 'UserError.otpAlive()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$otpAlive);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return otpAlive();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return otpAlive?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (otpAlive != null) {
      return otpAlive();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return otpAlive(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return otpAlive?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (otpAlive != null) {
      return otpAlive(this);
    }
    return orElse();
  }
}

abstract class otpAlive implements UserError {
  factory otpAlive() = _$otpAlive;
}

/// @nodoc
abstract class _$$otpDiedCopyWith<$Res> {
  factory _$$otpDiedCopyWith(_$otpDied value, $Res Function(_$otpDied) then) =
      __$$otpDiedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$otpDiedCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$otpDied>
    implements _$$otpDiedCopyWith<$Res> {
  __$$otpDiedCopyWithImpl(_$otpDied _value, $Res Function(_$otpDied) _then)
      : super(_value, _then);
}

/// @nodoc

class _$otpDied implements otpDied {
  _$otpDied();

  @override
  String toString() {
    return 'UserError.otpDied()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$otpDied);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return otpDied();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return otpDied?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (otpDied != null) {
      return otpDied();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return otpDied(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return otpDied?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (otpDied != null) {
      return otpDied(this);
    }
    return orElse();
  }
}

abstract class otpDied implements UserError {
  factory otpDied() = _$otpDied;
}

/// @nodoc
abstract class _$$wrongOTPCopyWith<$Res> {
  factory _$$wrongOTPCopyWith(
          _$wrongOTP value, $Res Function(_$wrongOTP) then) =
      __$$wrongOTPCopyWithImpl<$Res>;
}

/// @nodoc
class __$$wrongOTPCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$wrongOTP>
    implements _$$wrongOTPCopyWith<$Res> {
  __$$wrongOTPCopyWithImpl(_$wrongOTP _value, $Res Function(_$wrongOTP) _then)
      : super(_value, _then);
}

/// @nodoc

class _$wrongOTP implements wrongOTP {
  _$wrongOTP();

  @override
  String toString() {
    return 'UserError.wrongOTP()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$wrongOTP);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return wrongOTP();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return wrongOTP?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (wrongOTP != null) {
      return wrongOTP();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return wrongOTP(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return wrongOTP?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (wrongOTP != null) {
      return wrongOTP(this);
    }
    return orElse();
  }
}

abstract class wrongOTP implements UserError {
  factory wrongOTP() = _$wrongOTP;
}

/// @nodoc
abstract class _$$noPendingOTPCopyWith<$Res> {
  factory _$$noPendingOTPCopyWith(
          _$noPendingOTP value, $Res Function(_$noPendingOTP) then) =
      __$$noPendingOTPCopyWithImpl<$Res>;
}

/// @nodoc
class __$$noPendingOTPCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$noPendingOTP>
    implements _$$noPendingOTPCopyWith<$Res> {
  __$$noPendingOTPCopyWithImpl(
      _$noPendingOTP _value, $Res Function(_$noPendingOTP) _then)
      : super(_value, _then);
}

/// @nodoc

class _$noPendingOTP implements noPendingOTP {
  _$noPendingOTP();

  @override
  String toString() {
    return 'UserError.noPendingOTP()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$noPendingOTP);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return noPendingOTP();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return noPendingOTP?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (noPendingOTP != null) {
      return noPendingOTP();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return noPendingOTP(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return noPendingOTP?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (noPendingOTP != null) {
      return noPendingOTP(this);
    }
    return orElse();
  }
}

abstract class noPendingOTP implements UserError {
  factory noPendingOTP() = _$noPendingOTP;
}

/// @nodoc
abstract class _$$otpMaxTriesReachedCopyWith<$Res> {
  factory _$$otpMaxTriesReachedCopyWith(_$otpMaxTriesReached value,
          $Res Function(_$otpMaxTriesReached) then) =
      __$$otpMaxTriesReachedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$otpMaxTriesReachedCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$otpMaxTriesReached>
    implements _$$otpMaxTriesReachedCopyWith<$Res> {
  __$$otpMaxTriesReachedCopyWithImpl(
      _$otpMaxTriesReached _value, $Res Function(_$otpMaxTriesReached) _then)
      : super(_value, _then);
}

/// @nodoc

class _$otpMaxTriesReached implements otpMaxTriesReached {
  _$otpMaxTriesReached();

  @override
  String toString() {
    return 'UserError.otpMaxTriesReached()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$otpMaxTriesReached);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return otpMaxTriesReached();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return otpMaxTriesReached?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (otpMaxTriesReached != null) {
      return otpMaxTriesReached();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return otpMaxTriesReached(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return otpMaxTriesReached?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (otpMaxTriesReached != null) {
      return otpMaxTriesReached(this);
    }
    return orElse();
  }
}

abstract class otpMaxTriesReached implements UserError {
  factory otpMaxTriesReached() = _$otpMaxTriesReached;
}

/// @nodoc
abstract class _$$InternalErrorCopyWith<$Res> {
  factory _$$InternalErrorCopyWith(
          _$InternalError value, $Res Function(_$InternalError) then) =
      __$$InternalErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$InternalErrorCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$InternalError>
    implements _$$InternalErrorCopyWith<$Res> {
  __$$InternalErrorCopyWithImpl(
      _$InternalError _value, $Res Function(_$InternalError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$InternalError(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InternalError implements InternalError {
  _$InternalError(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'UserError.internalError(error: $error)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InternalError &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InternalErrorCopyWith<_$InternalError> get copyWith =>
      __$$InternalErrorCopyWithImpl<_$InternalError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return internalError(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return internalError?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (internalError != null) {
      return internalError(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return internalError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return internalError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (internalError != null) {
      return internalError(this);
    }
    return orElse();
  }
}

abstract class InternalError implements UserError {
  factory InternalError(final String error) = _$InternalError;

  String get error;
  @JsonKey(ignore: true)
  _$$InternalErrorCopyWith<_$InternalError> get copyWith =>
      throw _privateConstructorUsedError;
}
