// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_service.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$UserError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserErrorCopyWith<$Res> {
  factory $UserErrorCopyWith(UserError value, $Res Function(UserError) then) =
      _$UserErrorCopyWithImpl<$Res, UserError>;
}

/// @nodoc
class _$UserErrorCopyWithImpl<$Res, $Val extends UserError>
    implements $UserErrorCopyWith<$Res> {
  _$UserErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UserDoesNotExistImplCopyWith<$Res> {
  factory _$$UserDoesNotExistImplCopyWith(_$UserDoesNotExistImpl value,
          $Res Function(_$UserDoesNotExistImpl) then) =
      __$$UserDoesNotExistImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserDoesNotExistImplCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$UserDoesNotExistImpl>
    implements _$$UserDoesNotExistImplCopyWith<$Res> {
  __$$UserDoesNotExistImplCopyWithImpl(_$UserDoesNotExistImpl _value,
      $Res Function(_$UserDoesNotExistImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserDoesNotExistImpl implements UserDoesNotExist {
  _$UserDoesNotExistImpl();

  @override
  String toString() {
    return 'UserError.userDoesNotExist()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$UserDoesNotExistImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return userDoesNotExist();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return userDoesNotExist?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (userDoesNotExist != null) {
      return userDoesNotExist();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return userDoesNotExist(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return userDoesNotExist?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (userDoesNotExist != null) {
      return userDoesNotExist(this);
    }
    return orElse();
  }
}

abstract class UserDoesNotExist implements UserError {
  factory UserDoesNotExist() = _$UserDoesNotExistImpl;
}

/// @nodoc
abstract class _$$phoneNumberAlreadyTakenImplCopyWith<$Res> {
  factory _$$phoneNumberAlreadyTakenImplCopyWith(
          _$phoneNumberAlreadyTakenImpl value,
          $Res Function(_$phoneNumberAlreadyTakenImpl) then) =
      __$$phoneNumberAlreadyTakenImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$phoneNumberAlreadyTakenImplCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$phoneNumberAlreadyTakenImpl>
    implements _$$phoneNumberAlreadyTakenImplCopyWith<$Res> {
  __$$phoneNumberAlreadyTakenImplCopyWithImpl(
      _$phoneNumberAlreadyTakenImpl _value,
      $Res Function(_$phoneNumberAlreadyTakenImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$phoneNumberAlreadyTakenImpl implements phoneNumberAlreadyTaken {
  _$phoneNumberAlreadyTakenImpl();

  @override
  String toString() {
    return 'UserError.phoneNumberAlreadyTaken()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$phoneNumberAlreadyTakenImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return phoneNumberAlreadyTaken();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return phoneNumberAlreadyTaken?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (phoneNumberAlreadyTaken != null) {
      return phoneNumberAlreadyTaken();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return phoneNumberAlreadyTaken(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return phoneNumberAlreadyTaken?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (phoneNumberAlreadyTaken != null) {
      return phoneNumberAlreadyTaken(this);
    }
    return orElse();
  }
}

abstract class phoneNumberAlreadyTaken implements UserError {
  factory phoneNumberAlreadyTaken() = _$phoneNumberAlreadyTakenImpl;
}

/// @nodoc
abstract class _$$otpAliveImplCopyWith<$Res> {
  factory _$$otpAliveImplCopyWith(
          _$otpAliveImpl value, $Res Function(_$otpAliveImpl) then) =
      __$$otpAliveImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$otpAliveImplCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$otpAliveImpl>
    implements _$$otpAliveImplCopyWith<$Res> {
  __$$otpAliveImplCopyWithImpl(
      _$otpAliveImpl _value, $Res Function(_$otpAliveImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$otpAliveImpl implements otpAlive {
  _$otpAliveImpl();

  @override
  String toString() {
    return 'UserError.otpAlive()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$otpAliveImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return otpAlive();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return otpAlive?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (otpAlive != null) {
      return otpAlive();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return otpAlive(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return otpAlive?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (otpAlive != null) {
      return otpAlive(this);
    }
    return orElse();
  }
}

abstract class otpAlive implements UserError {
  factory otpAlive() = _$otpAliveImpl;
}

/// @nodoc
abstract class _$$otpDiedImplCopyWith<$Res> {
  factory _$$otpDiedImplCopyWith(
          _$otpDiedImpl value, $Res Function(_$otpDiedImpl) then) =
      __$$otpDiedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$otpDiedImplCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$otpDiedImpl>
    implements _$$otpDiedImplCopyWith<$Res> {
  __$$otpDiedImplCopyWithImpl(
      _$otpDiedImpl _value, $Res Function(_$otpDiedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$otpDiedImpl implements otpDied {
  _$otpDiedImpl();

  @override
  String toString() {
    return 'UserError.otpDied()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$otpDiedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return otpDied();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return otpDied?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (otpDied != null) {
      return otpDied();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return otpDied(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return otpDied?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (otpDied != null) {
      return otpDied(this);
    }
    return orElse();
  }
}

abstract class otpDied implements UserError {
  factory otpDied() = _$otpDiedImpl;
}

/// @nodoc
abstract class _$$wrongOTPImplCopyWith<$Res> {
  factory _$$wrongOTPImplCopyWith(
          _$wrongOTPImpl value, $Res Function(_$wrongOTPImpl) then) =
      __$$wrongOTPImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$wrongOTPImplCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$wrongOTPImpl>
    implements _$$wrongOTPImplCopyWith<$Res> {
  __$$wrongOTPImplCopyWithImpl(
      _$wrongOTPImpl _value, $Res Function(_$wrongOTPImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$wrongOTPImpl implements wrongOTP {
  _$wrongOTPImpl();

  @override
  String toString() {
    return 'UserError.wrongOTP()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$wrongOTPImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return wrongOTP();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return wrongOTP?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (wrongOTP != null) {
      return wrongOTP();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return wrongOTP(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return wrongOTP?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (wrongOTP != null) {
      return wrongOTP(this);
    }
    return orElse();
  }
}

abstract class wrongOTP implements UserError {
  factory wrongOTP() = _$wrongOTPImpl;
}

/// @nodoc
abstract class _$$noPendingOTPImplCopyWith<$Res> {
  factory _$$noPendingOTPImplCopyWith(
          _$noPendingOTPImpl value, $Res Function(_$noPendingOTPImpl) then) =
      __$$noPendingOTPImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$noPendingOTPImplCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$noPendingOTPImpl>
    implements _$$noPendingOTPImplCopyWith<$Res> {
  __$$noPendingOTPImplCopyWithImpl(
      _$noPendingOTPImpl _value, $Res Function(_$noPendingOTPImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$noPendingOTPImpl implements noPendingOTP {
  _$noPendingOTPImpl();

  @override
  String toString() {
    return 'UserError.noPendingOTP()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$noPendingOTPImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return noPendingOTP();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return noPendingOTP?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (noPendingOTP != null) {
      return noPendingOTP();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return noPendingOTP(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return noPendingOTP?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (noPendingOTP != null) {
      return noPendingOTP(this);
    }
    return orElse();
  }
}

abstract class noPendingOTP implements UserError {
  factory noPendingOTP() = _$noPendingOTPImpl;
}

/// @nodoc
abstract class _$$otpMaxTriesReachedImplCopyWith<$Res> {
  factory _$$otpMaxTriesReachedImplCopyWith(_$otpMaxTriesReachedImpl value,
          $Res Function(_$otpMaxTriesReachedImpl) then) =
      __$$otpMaxTriesReachedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$otpMaxTriesReachedImplCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$otpMaxTriesReachedImpl>
    implements _$$otpMaxTriesReachedImplCopyWith<$Res> {
  __$$otpMaxTriesReachedImplCopyWithImpl(_$otpMaxTriesReachedImpl _value,
      $Res Function(_$otpMaxTriesReachedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$otpMaxTriesReachedImpl implements otpMaxTriesReached {
  _$otpMaxTriesReachedImpl();

  @override
  String toString() {
    return 'UserError.otpMaxTriesReached()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$otpMaxTriesReachedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return otpMaxTriesReached();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return otpMaxTriesReached?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (otpMaxTriesReached != null) {
      return otpMaxTriesReached();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return otpMaxTriesReached(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return otpMaxTriesReached?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (otpMaxTriesReached != null) {
      return otpMaxTriesReached(this);
    }
    return orElse();
  }
}

abstract class otpMaxTriesReached implements UserError {
  factory otpMaxTriesReached() = _$otpMaxTriesReachedImpl;
}

/// @nodoc
abstract class _$$InternalErrorImplCopyWith<$Res> {
  factory _$$InternalErrorImplCopyWith(
          _$InternalErrorImpl value, $Res Function(_$InternalErrorImpl) then) =
      __$$InternalErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$InternalErrorImplCopyWithImpl<$Res>
    extends _$UserErrorCopyWithImpl<$Res, _$InternalErrorImpl>
    implements _$$InternalErrorImplCopyWith<$Res> {
  __$$InternalErrorImplCopyWithImpl(
      _$InternalErrorImpl _value, $Res Function(_$InternalErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$InternalErrorImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InternalErrorImpl implements InternalError {
  _$InternalErrorImpl(this.error);

  @override
  final String error;

  @override
  String toString() {
    return 'UserError.internalError(error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InternalErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InternalErrorImplCopyWith<_$InternalErrorImpl> get copyWith =>
      __$$InternalErrorImplCopyWithImpl<_$InternalErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() userDoesNotExist,
    required TResult Function() phoneNumberAlreadyTaken,
    required TResult Function() otpAlive,
    required TResult Function() otpDied,
    required TResult Function() wrongOTP,
    required TResult Function() noPendingOTP,
    required TResult Function() otpMaxTriesReached,
    required TResult Function(String error) internalError,
  }) {
    return internalError(error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? userDoesNotExist,
    TResult? Function()? phoneNumberAlreadyTaken,
    TResult? Function()? otpAlive,
    TResult? Function()? otpDied,
    TResult? Function()? wrongOTP,
    TResult? Function()? noPendingOTP,
    TResult? Function()? otpMaxTriesReached,
    TResult? Function(String error)? internalError,
  }) {
    return internalError?.call(error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? userDoesNotExist,
    TResult Function()? phoneNumberAlreadyTaken,
    TResult Function()? otpAlive,
    TResult Function()? otpDied,
    TResult Function()? wrongOTP,
    TResult Function()? noPendingOTP,
    TResult Function()? otpMaxTriesReached,
    TResult Function(String error)? internalError,
    required TResult orElse(),
  }) {
    if (internalError != null) {
      return internalError(error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UserDoesNotExist value) userDoesNotExist,
    required TResult Function(phoneNumberAlreadyTaken value)
        phoneNumberAlreadyTaken,
    required TResult Function(otpAlive value) otpAlive,
    required TResult Function(otpDied value) otpDied,
    required TResult Function(wrongOTP value) wrongOTP,
    required TResult Function(noPendingOTP value) noPendingOTP,
    required TResult Function(otpMaxTriesReached value) otpMaxTriesReached,
    required TResult Function(InternalError value) internalError,
  }) {
    return internalError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UserDoesNotExist value)? userDoesNotExist,
    TResult? Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult? Function(otpAlive value)? otpAlive,
    TResult? Function(otpDied value)? otpDied,
    TResult? Function(wrongOTP value)? wrongOTP,
    TResult? Function(noPendingOTP value)? noPendingOTP,
    TResult? Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult? Function(InternalError value)? internalError,
  }) {
    return internalError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UserDoesNotExist value)? userDoesNotExist,
    TResult Function(phoneNumberAlreadyTaken value)? phoneNumberAlreadyTaken,
    TResult Function(otpAlive value)? otpAlive,
    TResult Function(otpDied value)? otpDied,
    TResult Function(wrongOTP value)? wrongOTP,
    TResult Function(noPendingOTP value)? noPendingOTP,
    TResult Function(otpMaxTriesReached value)? otpMaxTriesReached,
    TResult Function(InternalError value)? internalError,
    required TResult orElse(),
  }) {
    if (internalError != null) {
      return internalError(this);
    }
    return orElse();
  }
}

abstract class InternalError implements UserError {
  factory InternalError(final String error) = _$InternalErrorImpl;

  String get error;
  @JsonKey(ignore: true)
  _$$InternalErrorImplCopyWith<_$InternalErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
